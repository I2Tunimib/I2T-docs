"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[786],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=l(n),h=o,m=d["".concat(c,".").concat(h)]||d[h]||p[h]||r;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6008:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return d}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],i={sidebar_position:2},c="Store",l={unversionedId:"frontend/store",id:"frontend/store",title:"Store",description:"In the store resides data necessary to update the view",source:"@site/docs/frontend/store.md",sourceDirName:"frontend",slug:"/frontend/store",permalink:"/I2T-docs/frontend/store",editUrl:"https://github.com/I2Tunimib/I2T-docs/docs/frontend/store.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Architecture",permalink:"/I2T-docs/frontend/architecture"},next:{title:"Thunk middleware",permalink:"/I2T-docs/frontend/thunk"}},u=[{value:"Slice structure",id:"slice-structure",children:[{value:"[sliceName].slice.ts",id:"slicenameslicets",children:[],level:3},{value:"[sliceName].selectors.ts",id:"slicenameselectorsts",children:[],level:3},{value:"[sliceName].thunks.ts",id:"slicenamethunksts",children:[],level:3}],level:2}],p={toc:u};function d(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"store"},"Store"),(0,r.kt)("p",null,"In the store resides data necessary to update the view\nof the application. ",(0,r.kt)("strong",{parentName:"p"},"Redux")," is used for this purpose which helps in building\napplications that behave consistently by centralizing the application state\nand logic, enabling powerful capabilities like undo/redo and state persistence."),(0,r.kt)("p",null,"While Redux increases the complexity and verbosity of the application,\nby introducing three software layers for the interaction and data flow between\nReact components and the application store, it also allows components, composed in any hierarchy, to access the global store without any dependency.\nIndeed, pure React has troubles in propagating data between siblings components, and in general the data for the leaf components needs to be forwarded\ndown through many layers of the components tree. Redux solves this problem, by granting each component direct access to a global store and retrieve\nthe needed data for each of them."),(0,r.kt)("p",null,"SemTUI utilizes the application store for many purposes: handling data\nchanges in an efficient way, storing API responses, caching data, and handling\nglobal actions between components. The most important use of it is to\nmaintain the tabular data in memory in such a way that changes to it are\nmade efficiently. In particular, the table data is treated as a database-like\nstructure where the entities are the columns, rows and cells, and relations\nexist between each other. Redux calls this representation as normalized state.\nA normalized state enables one to look up entities directly by their IDs\noptimizing most of the operations, for example preventing users to constantly\niterate over arrays to find a specific entity."),(0,r.kt)("p",null,"The combination of both a normalized and globally available state makes\nit possible to initiate actions from various components, e.g.: deleting a column from a contextual menu inside a component representing the same column, but also from a component completely external to the table, without\ngiving up on performances and without passing unneeded properties to nested\nReact components."),(0,r.kt)("p",null,"The interaction between a component and a store is mediated by:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Action dispatcher"),": a component dispatch an action which describes the\ncontent of a request to modify a certain part of the store;"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reducer function"),": a function which determines changes to an application\u2019s state. A reducer receives the payload of the action and applies a\ntransformation to the store returning a new state. A reducer isn\u2019t allowed to execute any side effects, e.g.: make an asynchornous call to an\nAPI, instead it is a pure function, meaning it always returns the same\nresult given the same input and it doesn\u2019t depends on any external\nevent other than the action."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Selector"),": finally, a selector is invoked in a component to access and\nreturn part of the store, by also applying, if necessary, a transformation\nfunction before rerendering its view. Each time a dependency of a\nselector changes, the return value of the selector is recomputed and the\ncomponent gets rerendered to reflect the changes. Some libraries also\nintroduce memoization for the selectors, caching results by comparing\ntheir dependencies and return values. Before recomputing a result, the\ncache is first checked returning the cached value if present.")),(0,r.kt)("div",{style:{textAlign:"center"}},(0,r.kt)("img",{style:{width:"600px"},src:"/I2T-docs/img/dataflow-redux.png"})),(0,r.kt)("h2",{id:"slice-structure"},"Slice structure"),(0,r.kt)("p",null,"SemTUI organizes its store in slices as suggested from the ",(0,r.kt)("a",{parentName:"p",href:"https://redux-toolkit.js.org/tutorials/quick-start"},"Redux Toolkit documentation"),".\nEach slice defines a part of the store state, also defining how the state should change based on an action.\nEach store slice of the application has a structure based on the previously depicted dataflow:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"\ud83d\udce6table\n \u2523 \ud83d\udcc2interfaces          // types definitions for the slice\n \u2523 \ud83d\udcc2utils               // utility functions resusable for the slice\n \u2523 \ud83d\udcdctable.selectors.ts  // selector for the slice\n \u2523 \ud83d\udcdctable.slice.ts      // state and reducers for the slice\n \u2517 \ud83d\udcdctable.thunk.ts      // async actions for the slice (will be presented in the next section)\n")),(0,r.kt)("h3",{id:"slicenameslicets"},"[","sliceName","]",".slice.ts"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example of slice"',title:'"Example',of:!0,'slice"':!0},"// The slice defines an initial state\nconst initialState: TableState = {\n  entities: {\n    tableInstance: {},\n    columns: { byId: {}, allIds: [] },\n    rows: { byId: {}, allIds: [] }\n  },\n  ...\n};\n// Create a slice\nexport const tableSlice = createSliceWithRequests({\n  name: 'table',\n  initialState,\n  // reducers are functions that change the state for an action\n  reducers: {\n    setRows: (state, action: PayloadAction<Rows>) => {\n      const rows = action.payload\n      // redux toolkit internally handles variables mutation, so that variables can be mutated without\n      // worrying about creating a new variable by copying old and new values\n      state.entities.rows = rows;\n    },\n    ...\n  }\n});\n\n// Export actions automatically created from the slice reducercs (thanks to Redux Toolkit)\nexport const {\n  setRows,\n  ...\n} = tableSlice.actions;\n// Export slice reducers\nexport default tableSlice.reducer;\n")),(0,r.kt)("p",null,"Actions can then be dispatched from any components to update the state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const SomeComponent = () => {\n  // useAppDispatch instead of useDispatch, so that types are correctly inferred\n  const dispatch = useAppDispatch();\n\n  const onClick = () => {\n    dispatch(setRows(someRows));\n  },\n  \n  return (\n    ...\n  )\n}\n")),(0,r.kt)("h3",{id:"slicenameselectorsts"},"[","sliceName","]",".selectors.ts"),(0,r.kt)("p",null,"Selectors are written using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Reselect")," library, so that memoization is applied to selector functions. Memoization allows components to rerender without re-executing a selector function if the input of a selector didn't change. More deatils are available in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/reselect"},"GitHub documentaion"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example selector"',title:'"Example','selector"':!0},"// create an input selector. An input selector takes as input the entire state composed by slices and returns part of the state\nconst selectRowsInput = (state: RootState) => state.table.entities;\n\n// create output selector. An output selector takes as input one, or more input \n// selectors and outputs a transformation of the states returned from the input selectors.\n// N.B.: output selectors can also be input selectors.\nexport const selectRows = createSelector(\n  selectRowsInput,\n  (entities) => entities.rows\n);\n")),(0,r.kt)("p",null,"A component can then use an output selector to select part of the state. Selector are revaluated each time an input state changes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const SomeComponent = () => {\n  // useAppSelector instead of useSelector, so that types are correctly inferred\n  const rows = useAppSelector(selectRows)\n  \n  return (\n    <>\n      {rows.map((row) => <div>row.id</div>)}\n    </>\n  )\n}\n")),(0,r.kt)("h3",{id:"slicenamethunksts"},"[","sliceName","]",".thunks.ts"),(0,r.kt)("p",null,"While a more detailed explanation of thunks is presented in the next section, here's an overview of a slice thunk file. A Thunk is essentialy a middleware which can execute async logic when an action is dispatched, before reaching a reducer function. A ",(0,r.kt)("inlineCode",{parentName:"p"},"*.thunk.ts")," file contains a set of thunks just like the following one:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example of thunk"',title:'"Example',of:!0,'thunk"':!0},"export const getTable = createAsyncThunk(\n  `${ACTION_PREFIX}/getTable`,\n  async (params: Record<string, string | number>) => {\n    // query an api endpoint\n    const response = await tableAPI.getTable(params);\n    return response.data;\n  }\n);\n")),(0,r.kt)("p",null,"A component can then dispatch a thunk action as any other action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"const SomeComponent = () => {\n  const dispatch = useAppDispatch();\n\n  const onClick = () => {\n    dispatch(getTable());\n  },\n  \n  return (\n    ...\n  )\n}\n")))}d.isMDXComponent=!0}}]);