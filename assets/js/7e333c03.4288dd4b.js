"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[663],{3905:(e,n,r)=>{r.d(n,{Zo:()=>d,kt:()=>g});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function a(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function s(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var c=t.createContext({}),l=function(e){var n=t.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):a(a({},n),e)),r},d=function(e){var n=l(e.components);return t.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(r),g=i,f=u["".concat(c,".").concat(g)]||u[g]||p[g]||o;return r?t.createElement(f,a(a({ref:n},d),{},{components:r})):t.createElement(f,a({ref:n},d))}));function g(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var l=2;l<o;l++)a[l]=r[l];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}u.displayName="MDXCreateElement"},2894:(e,n,r)=>{r.r(n),r.d(n,{frontMatter:()=>o,contentTitle:()=>a,metadata:()=>s,toc:()=>c,default:()=>d});var t=r(7462),i=(r(7294),r(3905));const o={sidebar_position:2},a="Backend Integration",s={unversionedId:"backend/guide-new-category/backend",id:"backend/guide-new-category/backend",title:"Backend Integration",description:"1. Create the new service module",source:"@site/docs/backend/guide-new-category/backend.md",sourceDirName:"backend/guide-new-category",slug:"/backend/guide-new-category/backend",permalink:"/I2T-docs/backend/guide-new-category/backend",editUrl:"https://github.com/I2Tunimib/I2T-docs/docs/backend/guide-new-category/backend.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/I2T-docs/backend/guide-new-category/introduction"},next:{title:"Frontend Integration",permalink:"/I2T-docs/backend/guide-new-category/frontend"}},c=[{value:"1. Create the new service module",id:"1-create-the-new-service-module",children:[],level:3},{value:"2. Create the Controller",id:"2-create-the-controller",children:[],level:3},{value:"3. Register the Routes",id:"3-register-the-routes",children:[],level:3},{value:"4. Update Configuration",id:"4-update-configuration",children:[],level:3},{value:"5. Logger Integration",id:"5-logger-integration",children:[],level:3}],l={toc:c};function d({components:e,...n}){return(0,i.kt)("wrapper",(0,t.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"backend-integration"},"Backend Integration"),(0,i.kt)("h3",{id:"1-create-the-new-service-module"},"1. Create the new service module"),(0,i.kt)("p",null,"The first step is to define the backend logic for the new Service Category.\nEach category has a dedicated folder that contains:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a pipeline file, which handles the main execution flow, "),(0,i.kt)("li",{parentName:"ul"},"a utility file, with helper functions used within the pipeline.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/services/newServiceOperation/newServiceOperation-pipeline.js"',title:'"src/api/services/newServiceOperation/newServiceOperation-pipeline.js"'},"import config from '../../../config/index.js';\nimport { utilityFunction } from './utils.js';\n\nconst { newCategories } = config;\n\nconst newServiceOperationPipeline = async (reqBody) => {\n  const { serviceId, ...rest } = reqBody;\n\n  // Retrieve the specific service configuration\n  const service = newCategories[serviceId];\n\n  if (!service) {\n    throw new Error('Service not found');\n  }\n\n  const {\n    info,\n    requestTransformer,\n    responseTransformer\n  } = service;\n\n  // Check that the required transformation functions exist\n  if (!requestTransformer) {\n    throw new Error('No request transformer function found');\n  }\n  if (!responseTransformer) {\n    throw new Error('No response transformer function found');\n  }\n\n  const { items, ...props } = rest;\n\n  // Prepare the request structure\n  const req = {\n    original: { items, props },\n    ...(info.private.processRequest && {\n      processed: { items: utilityFunction(items), props }\n    })\n  };\n\n  // Execute the external service request\n  const serviceResponse = await requestTransformer(req);\n\n  // Transform and format the response for the application\n  const transformedResponse = await responseTransformer(req, serviceResponse);\n\n  return transformedResponse;\n};\n\nexport default newServiceOperationPipeline;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/services/newServiceOperationPipeline/utils.js"',title:'"src/api/services/newServiceOperationPipeline/utils.js"'},"export const utilityFunction = (data) => {\n// Example: process or clean up input data before sending it to the service\nreturn data;\n};\n")),(0,i.kt)("h3",{id:"2-create-the-controller"},"2. Create the Controller"),(0,i.kt)("p",null,"The controller acts as the backend entry point for the new service category.\nIt handles incoming HTTP requests and invokes the corresponding service pipeline."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/controllers/newServiceOperation.controller.js"',title:'"src/api/controllers/newServiceOperation.controller.js"'},"import newServiceOperationPipeline from \"../services/newServiceOperation/newServiceOperation-pipeline.js\";\nimport config from '../../config/index.js';\n\nconst { newCategories } = config;\n\nconst NewServiceOperationController = {\n  list: async (req, res, next) => {\n    res.json(Object.keys(newCategories).map((key) => ({ id: key, ...newCategories[key].info.public })))\n  },\n  newCategoryService: async (req, res, next) => {\n    try {\n      res.json(await newServiceOperationPipeline(req.body))\n    } catch (err) {\n      next(err);\n    }\n  }\n}\n\nexport default NewServiceOperationController;\n")),(0,i.kt)("p",null,"If the new category should also appear in the global configuration endpoint, update the config\ncontroller to include it adding this few lines of code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/controllers/config.controller.js"',title:'"src/api/controllers/config.controller.js"'},"const { extenders: extConfig, ..., newCategories: newCatConfig } = config;\n...\nconst ConfigController = {\n  getConfig: async (req, res, next) => {\n    ...\n    const newCategories = getPublicConfiguration(newCatConfig);\n    try {\n      res.json({\n        ...\n        newCategories,\n      });\n    } catch (err) {\n      next(err);\n    }\n  }\n};\n")),(0,i.kt)("h3",{id:"3-register-the-routes"},"3. Register the Routes"),(0,i.kt)("p",null,"After creating the controller, the next step is to expose the new Service Category via REST API\nendpoints. This requires defining a dedicated route file and registering it in the main router."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/routes/newCategoryService.route.js"',title:'"src/api/routes/newCategoryService.route.js"'},"import { Router } from 'express';\nimport NewServiceOperationController from '../controllers/newServiceOperation.controller.js';\nimport asyncMiddleware from '../middleware/async.middleware.js';\n\nconst router = Router();\n\n// List all available services\nrouter.get('/list', asyncMiddleware(NewServiceOperationController.list));\n// Execute a service\nrouter.post('/*', asyncMiddleware(NewServiceOperationController.execute));\n\nexport default router;\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/routes/index.js"',title:'"src/api/routes/index.js"'},'...\nimport newServiceOperationRoutes from "./newServiceOperation.route.js";\n...\n// Existing routes\nrouter.use("/config", configRoutes);\n...\n// Register new service category\nrouter.use("/newCategories", newServiceOperationRoutes);\n...\n')),(0,i.kt)("h3",{id:"4-update-configuration"},"4. Update Configuration"),(0,i.kt)("p",null,"To integrate a new Service Category into the backend, it is necessary to register it in the\napplication configuration so that the system can load and manage its services dynamically."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/config/index.js"',title:'"src/config/index.js"'},"const { services } = CONFIG;\n...\nconst loadNewCategories = async () => {\n  const basePath = `${process.env.PWD}/src${services.path}/newCategories`;\n\n  const newCategories = readdirSync(basePath).filter(\n    (newCategory) => !services.exclude?.newCategories?.includes(newCategory)\n  );\n\n  return newCategories.reduce(async (acc, serviceKey) => {\n    const servicePath = `${basePath}/${serviceKey}`;\n\n    const { default: info } = await import(`file:///${servicePath}/index.js`);\n    const { default: requestTransformer } = await import(\n            `file:///${servicePath}/requestTransformer.js`\n            );\n    const { default: responseTransformer } = await import(\n            `file:///${servicePath}/responseTransformer.js`\n            );\n\n    (await acc)[serviceKey] = {\n      info,\n      requestTransformer,\n      responseTransformer,\n    };\n    return acc;\n  }, {});\n};\n...\n/**\n * Load initial configuration\n */\nconst loadConfig = async () => {\n  ...\n  const newCategories = await loadNewCategories();\n  ...\n  return {\n    // existing fields\n    newCategories,\n    ...\n  };\n\n")),(0,i.kt)("h3",{id:"5-logger-integration"},"5. Logger Integration"),(0,i.kt)("p",null,"The logger middleware and service track all operations performed on datasets and tables.\nFor a new service category, it's necessary to extend both the middleware and LoggerService to support\nlogging of the new category."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/middleware/logger.js"',title:'"src/api/middleware/logger.js"'},'const OPERATION_TYPES = {\n  ...\n  NEW_SERVICE_OPERATION: "NEW_SERVICE_OPERATION",\n};\n\nconst ROUTE_PATTERNS = {\n  ...\n  NEW_CATEGORIES: "/api/newCategories",\n};\n...\nasync function routeLogs(req) {\n  ...\n  // Handle different route types\n  if (url.includes(ROUTE_PATTERNS.RECONCILERS)) {\n    await handleReconciliationRoute(req, url);\n  } ... {\n  } else if (url.includes(ROUTE_PATTERNS.NEW_CATEGORIES)) {\n    await handleNewServiceOperationRoute(req, url);\n  }\n}\n...\nasync function handleNewServiceOperationRoute(req, url) {\n  let requestedNewCategory = extractServiceFromUrl(url, ROUTE_PATTERNS.NEW_CATEGORIES);\n  if (req.body && req.body.serviceId) {\n      requestedNewCategory += `-${req.body.serviceId}`;\n  }\n  const taskInfos = await getTaskInfos(req);\n  if (taskInfos && taskInfos.length === 3) {\n    const [tableId, datasetId, columnName] = taskInfos;\n    LoggerService.logNewServiceOperation({\n      datasetId,\n      tableId,\n      columnName,\n      service: requestedNewCategory,\n      additionalData: req._rawBody || req.body,\n    });\n  }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/api/services/logger/logger.service.js "',title:'"src/api/services/logger/logger.service.js','"':!0},'class LoggerService {\n  static OPERATION_TYPES = {\n    ...\n    NEW_SERVICE_OPERATION: "NEW_SERVICE_OPERATION",\n};\n...\nstatic logNewServiceOperation({\n  datasetId,\n  tableId,\n  columnName,\n  service,\n  additionalData = {},\n}) {\n  return LoggerService.#writeLog({\n    datasetId,\n    tableId,\n    operationType: LoggerService.OPERATION_TYPES.NEW_SERVICE_OPERATION,\n    options: { columnName, service },\n    additionalData,\n  });\n}\n...\nconst labels = {\n  ...\n  [LoggerService.OPERATION_TYPES.NEW_SERVICE_OPERATION]: "NewCategory",\n};\nconst serviceLabel = labels[operationType] || "Unknown";\n...\n')),(0,i.kt)("p",null,"Once all backend integration steps are completed, create a dedicated folder for the new\nService Category inside ",(0,i.kt)("inlineCode",{parentName:"p"},"src/services"),". Each individual service for this category\nshould then be implemented within this folder, including its own ",(0,i.kt)("inlineCode",{parentName:"p"},"index.js"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"requestTransformer.js"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"responseTransformer.js")," files as needed."))}d.isMDXComponent=!0}}]);