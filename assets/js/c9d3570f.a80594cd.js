"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[1],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(t),g=a,m=p["".concat(l,".").concat(g)]||p[g]||u[g]||o;return t?r.createElement(m,s(s({ref:n},d),{},{components:t})):r.createElement(m,s({ref:n},d))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=p;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=t[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},7841:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>o,contentTitle:()=>s,metadata:()=>i,toc:()=>l,default:()=>d});var r=t(7462),a=(t(7294),t(3905));const o={sidebar_position:3},s="Frontend Integration",i={unversionedId:"guide-new-category/frontend",id:"guide-new-category/frontend",title:"Frontend Integration",description:"1. Update API Service Module",source:"@site/docs/guide-new-category/frontend.md",sourceDirName:"guide-new-category",slug:"/guide-new-category/frontend",permalink:"/I2T-docs/guide-new-category/frontend",editUrl:"https://github.com/I2Tunimib/I2T-docs/docs/guide-new-category/frontend.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Backend Integration",permalink:"/I2T-docs/guide-new-category/backend"},next:{title:"Architecture",permalink:"/I2T-docs/frontend/architecture"}},l=[{value:"1. Update API Service Module",id:"1-update-api-service-module",children:[],level:3},{value:"2. Update the Global Store (Config and Table Slices)",id:"2-update-the-global-store-config-and-table-slices",children:[],level:3},{value:"3. Add UI Components",id:"3-add-ui-components",children:[],level:3},{value:"4. Update Dynamic Forms (if applicable)",id:"4-update-dynamic-forms-if-applicable",children:[],level:3}],c={toc:l};function d({components:e,...n}){return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"frontend-integration"},"Frontend Integration"),(0,a.kt)("h3",{id:"1-update-api-service-module"},"1. Update API Service Module"),(0,a.kt)("p",null,"The first step is to extend the main API layer to include support for the new Service Category.\nEach category communicates with its corresponding backend endpoint through a dedicated API method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/services/api/table.ts"',title:'"src/services/api/table.ts"'},'const tableAPI = {\n  // New endpoint for newCategoryService\n  newCategoryService: async (\n    baseUrl: string,\n    data: any,\n    tableId?: string,\n    datasetId?: string,\n    columnName?: string\n  ) => {\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${localStorage.getItem("token")}`,\n    };\n\n    if (tableId && datasetId) {\n      console.log(\n        `Adding headers for newCategoryService: tableId: ${tableId}, datasetId: ${datasetId}, columnName: ${columnName}`\n      );\n\n      // Clean values to remove BOM and other problematic characters\n      const cleanTableId = tableId.replace(/\\uFEFF/g, "").trim();\n      const cleanDatasetId = datasetId.replace(/\\uFEFF/g, "").trim();\n      const cleanColumnName = columnName ? columnName.replace(/\\uFEFF/g, "").trim() : "";\n\n      headers["X-Table-Dataset-Info"] = `tableId:${cleanTableId};datasetId:${cleanDatasetId}${\n        cleanColumnName ? `;columnName:${cleanColumnName}` : ""\n      }`;\n    }\n    console.log("newServiceOperation request headers:", headers);\n\n    // Clean baseUrl to remove BOM characters\n    const cleanBaseUrl = baseUrl.replace(/\\uFEFF/g, "").trim();\n    console.log("newServiceOperation request URL:", `newCategoryService${cleanBaseUrl}`);\n    console.log("newServiceOperation request data:", data);\n    console.log("newCategoryService request config:", { headers, clearCacheEntry: true });\n\n    return apiClient.post(`newCategories${cleanBaseUrl}`, data, {\n      headers, \n      clearCacheEntry: true, // Bypass cache for this request\n    });\n  },\n...\n};\n')),(0,a.kt)("h3",{id:"2-update-the-global-store-config-and-table-slices"},"2. Update the Global Store (Config and Table Slices)"),(0,a.kt)("p",null,"In this step, integrate the new Category Service into the frontend global store.\nThis involves updating the Redux slices and selectors for configuration (",(0,a.kt)("inlineCode",{parentName:"p"},"config"),") and tables (",(0,a.kt)("inlineCode",{parentName:"p"},"table"),") so that\nthe application can:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Load available newCategory services from the backend,"),(0,a.kt)("li",{parentName:"ul"},"Track UI state (open dialog, selection, etc.),"),(0,a.kt)("li",{parentName:"ul"},"Handle requests and update the table state accordingly.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/config/interfaces/config.ts"',title:'"src/store/slices/config/interfaces/config.ts"'},"export interface IConfigState extends RequestEnhancedState {\n  app: AppConfig;\n  entities: {\n    ...\n    newCategories: newCategoriesState;\n  };\n}\n\nexport interface newCategoriesState extends BaseState<newCategory> {}\n\nexport interface newCategory extends Record<string, any> {\n  id: ID;\n  name: string;\n  relativeUrl: string;\n  description: string;\n  formParams: FormInputParams[];\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/config/config.slice.ts"',title:'"src/store/slices/config/config.slice.ts"'},'const initialState: IConfigState = {\n  app: CONFIG,\n  entities: {\n    ...,\n    newCategories: { byId: {}, allIds: [] },\n  },\n  _requests: { byId: {}, allIds: [] },\n\n  const newCategories = payload.newCategories || payload.extensions || [];\n\n  console.log("Config slice - found data:", {\n    ...,\n      newCategories: {\n        type: typeof newCategories,\n        isArray: Array.isArray(newCategories),\n        length: newCategories?.length,\n      },\n    });\n\n    // Process newCategories if they exist and are an array\n    if (Array.isArray(newCategories)) {\n    newCategories.forEach((newCategory) => {\n        state.entities.newCategories.byId[newCategory.id] = newCategory;\n        state.entities.newCategories.allIds.push(newCategory.id);\n      });\n    } else {\n      console.warn("Config slice - newCategories not found or not an array");\n    }\n  }),\n});\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/config/config.selectors.ts"',title:'"src/store/slices/config/config.selectors.ts"'},"// select newCategories\nexport const selectNewCategories = (state: RootState) =>\n  state.config.entities.newCategories;\n\nexport const selectNewCategoriesAsObject = createSelector(\n  selectNewCategories,\n  (newCategories) => newCategories.byId\n);\n\nexport const selectNewCategoriesAsArray = createSelector(\n  selectNewCategories,\n  (newCategories) =>\n    newCategories.allIds\n      .map((id) => newCategories.byId[id])\n      .sort((a, b) => a.name.localeCompare(b.name))\n);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/interfaces/table.ts"',title:'"src/store/slices/table/interfaces/table.ts"'},'export interface TableUIState {\n  ...\n  openNewServiceOperationDialog: boolean;\n  ...\n}\n\nexport interface newCategoryServiceFulfilledPayload {\n    columns: ColumnState["byId"];\n    rows: RowState["byId"];\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.selectors.ts"',title:'"src/store/slices/table/table.selectors.ts"'},"export const selectNewCategoryServiceRequestStatus = createSelector(\n  selectRequests,\n  (requests) => getRequestStatus(requests, TableThunkActions.NEW_CATEGORY_SERVICE)\n);\n/**\n * Get new service operation dialog status.\n */\nexport const selectNewServiceOperationDialogStatus = createSelector(\n  selectUIState,\n  (ui) => ui.openNewServiceOperationDialog\n);\nexport const selectIsNewCategoryServiceButtonEnabled = createSelector(\n  selectUIState,\n  selectColumnsState,\n  ({ selectedColumnsIds, selectedCellIds }, columns) => {\n    const colIds = Object.keys(selectedColumnsIds);\n    const cellIds = Object.keys(selectedCellIds);\n    if (colIds.length === 0) {\n      return false;\n    }\n    const onlyColsSelected = !cellIds.some((cellId) => {\n      const [_, colId] = getIdsFromCell(cellId);\n      return !(colId in selectedColumnsIds);\n    });\n    return onlyColsSelected;\n  }\n);\nexport const selectColumnForNewServiceOperation = createSelector(\n  selectIsNewCategoryServiceButtonEnabled,\n  selectSelectedColumnIds,\n  selectRowsState,\n  (isNewCategoryServiceButtonEnabled, selectedColumns, rowEntities) => {\n    if (isNewCategoryServiceButtonEnabled) {\n      const colId = Object.keys(selectedColumns)[0];\n\n      return rowEntities.allIds.reduce((acc, rowId) => {\n        const cell = rowEntities.byId[rowId].cells[colId];\n        const trueMeta = cell.metadata.find((metaItem) => metaItem.match);\n        if (trueMeta) {\n          // eslint-disable-next-line prefer-destructuring\n          acc[rowId] = trueMeta.id;\n        }\n        return acc;\n      }, {} as Record<string, any>);\n    }\n    return [];\n  }\n);\n\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.slice.ts"',title:'"src/store/slices/table/table.slice.ts"'},'import { ..., newCategoryService, } from "./table.thunk";\nconst initialState: TableState = {\n  entities: {...},\n  ui: {..., openNewServiceOperationDialog: false,}\n  ...\n}\nexport const tableSlice = createSliceWithRequests({\n  name: "table",\n  initialState,\n  reducers: { ... },\n    extraRules: (builder) => builder\n      .addCase(\n        newCategoryService.fulfilled,\n        (state, action: PayloadAction<Payload<ExtendThunkResponseProps>>) => {\n          const {\n            data,\n            newCategory,\n            selectedColumnId,\n            undoable = true,\n          } = action.payload;\n\n          const { columns, meta, originalColMeta } = data;\n          const newColumnsIds = Object.keys(columns);\n          return produceWithPatch(\n            state,\n            undoable,\n            (draft) => {\n              const selectedColumnIndex =\n                draft.entities.columns.allIds.findIndex(\n                  (colId) => colId === selectedColumnId\n                );\n\n              newColumnsIds.forEach((newColId, newColIndex) => {\n                const {\n                  metadata: columnMetadata,\n                  cells,\n                  label,\n                  ...rest\n                } = columns[newColId];\n\n                // add new column\n                draft.entities.columns.byId[newColId] = {\n                  id: newColId,\n                  label,\n                  metadata: getColumnMetadata(columnMetadata),\n                  status: ColumnStatus.EMPTY,\n                  context: {},\n                  ...getColumnAnnotationMeta(columnMetadata),\n                  ...rest,\n                };\n\n                // add rows\n\n                draft.entities.rows.allIds.forEach((rowId) => {\n                  const newCell = createCell(rowId, newColId, cells[rowId]);\n                  if (newCell.metadata.length === 0) {\n                    newCell.annotationMeta = {\n                      annotated: false,\n                      match: {\n                        value: false,\n                      },\n                    };\n                  }\n                  draft.entities.rows.byId[rowId].cells[newColId] = newCell;\n                  if (newCell.metadata.length > 0) {\n                    updateContext(draft, newCell);\n                  }\n                });\n\n                draft.entities.columns.byId[newColId].status = getColumnStatus(\n                  draft,\n                  newColId\n                );\n\n                // Insert the new column right after the selected column\n                if (!draft.entities.columns.allIds.includes(newColId)) {\n                  draft.entities.columns.allIds.push(newColId);\n                }\n              });\n              updateNumberOfReconciliatedCells(draft);\n              //add additional meta if needed (up to now only properties)\n              if (originalColMeta && originalColMeta.originalColName) {\n                if (\n                  draft.entities.columns.byId[originalColMeta.originalColName]\n                    .metadata[0].property\n                ) {\n                  draft.entities.columns.byId[\n                    originalColMeta.originalColName\n                  ].metadata[0].property = [\n                    ...draft.entities.columns.byId[\n                      originalColMeta.originalColName\n                    ].metadata[0].property,\n                    ...originalColMeta.properties,\n                  ];\n                } else {\n                  draft.entities.columns.byId[\n                    originalColMeta.originalColName\n                  ].metadata[0].property = originalColMeta.properties;\n                }\n              }\n            },\n            (draft) => {\n              draft.entities.tableInstance.lastNewCategoryServicedDate =\n                new Date().toISOString();\n            }\n          );\n        }\n      ),\n});\n\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.thunk.ts"',title:'"src/store/slices/table/table.thunk.ts"'},'import { ..., NewCategory, } from "../config/interfaces/config";\nexport enum TableThunkActions {\n  ...,\n  NEW_SERVICE_OPERATION = "newServiceOperation",\n}\nconst getRequestFormValuesNewServiceOperation = (\n  formParams: FormInputParams[],\n  formValues: Record<string, any>,\n  table: TableState,\n  newCategory?: NewCategory\n) => {\n  if (!formParams) {\n    return {};\n  }\n\n  const { ui, entities } = table;\n  const { rows } = entities;\n  const selectedColumnsIds = Object.keys(table.ui.selectedColumnsIds);\n  console.log("getting request form values", newCategory);\n  const requestParams = {} as Record<string, any>;\n\n  requestParams.items = selectedColumnsIds.reduce((acc, key) => {\n    acc[key] = getColumnValues(key, rows);\n    return acc;\n  }, {} as Record<string, any>);\n\n  formParams.forEach(({ id, inputType }) => {\n    if (formValues[id]) {\n      if (inputType === "selectColumns") {\n        requestParams[id] = getColumnValues(formValues[id], rows);\n      } else if (inputType === "multipleColumnSelect") {\n        requestParams[id] = {};\n        for (const colId of formValues[id]) {\n          requestParams[id][colId] = getColumnValues(colId, rows);\n        }\n      } else {\n        requestParams[id] = formValues[id];\n      }\n    }\n  });\n  \n  return requestParams;\n};\n\nexport type NewCategoryServiceThunkInputProps = {\n  newCategory: NewCategory;\n  formValues: Record<string, any>;\n};\n\nexport type NewCategoryServiceThunkResponseProps = {\n  newCategory: NewCategory;\n  selectedColumnId: string;\n  data: any;\n};\n\nexport const newCategoryService = createAsyncThunk<\n  NewCategoryServiceThunkResponseProps,\n  NewCategoryServiceThunkInputProps\n>(`${ACTION_PREFIX}/newCategoryService`, async (inputProps, { getState }) => {\n  const { newCategory, formValues } = inputProps;\n\n  const { table } = getState() as RootState;\n  const { relativeUrl, formParams, id } = newCategory;\n  const { entities, ui } = table;\n  const { tableInstance, columns } = entities;\n\n  const selectedColumnIds = Object.keys(ui.selectedColumnsIds);\n  const selectedColumnId = selectedColumnIds[0];\n  const columnName = columns.byId[selectedColumnId]?.label || "";\n\n  const params = getRequestFormValuesNewServiceOperation(formParams, formValues, table);\n\n  const response = await tableAPI.newServiceOperation(\n    relativeUrl,\n    {\n      serviceId: id,\n      ...params,\n    },\n    tableInstance.id,\n    tableInstance.idDataset,\n    columnName\n  );\n\n  return {\n    data: response.data,\n    newCategory,\n    selectedColumnId,\n  };\n});\n')),(0,a.kt)("h3",{id:"3-add-ui-components"},"3. Add UI Components"),(0,a.kt)("p",null,"Now, integrate the new Category Service into the frontend UI by creating the necessary components and interactions.\nSpecifically:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Add a new Category Service Dialog to allow users to select and execute a newCategory service. "),(0,a.kt)("li",{parentName:"ul"},"Update the SubToolbar to include a button that opens the Category Service Dialog. "),(0,a.kt)("li",{parentName:"ul"},"Update the ContextMenuColumn to allow right-click operations on columns for the new Category Service action. "),(0,a.kt)("li",{parentName:"ul"},"Connect all UI components to the Redux global store and async thunks to handle state and backend requests.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/pages/Viewer/TableViewer/NewCategoryServiceDialog.tsx"',title:'"src/pages/Viewer/TableViewer/NewCategoryServiceDialog.tsx"'},'import React, { forwardRef, Ref, ReactElement, useState, useEffect, FC } from "react";\nimport { useAppDispatch, useAppSelector } from "@hooks/store";\nimport {\n  Dialog,\n  DialogContent,\n  DialogContentText,\n  DialogTitle,\n  Divider,\n  FormControl,\n  IconButton,\n  MenuItem,\n  Select,\n  SelectChangeEvent,\n  Stack,\n  Slide,\n  Typography,\n} from "@mui/material";\nimport { TransitionProps } from "@mui/material/transitions";\nimport { HelpOutlineRounded } from "@mui/icons-material";\nimport { selectNewCategoryServiceRequestStatus } from "@store/slices/table/table.selectors";\nimport { updateUI } from "@store/slices/table/table.slice";\nimport { selectNewCategoriesAsArray } from "@store/slices/config/config.selectors";\nimport { NewCategory } from "@store/slices/config/interfaces/config";\nimport styled from "@emotion/styled";\nimport { newCategoryService } from "@store/slices/table/table.thunk";\nimport { useSnackbar } from "notistack";\nimport { SquaredBox } from "@components/core";\nimport DynamicNewServiceOperationForm from "@components/core/DynamicForm/DynamicForm";\n\nconst Transition = forwardRef(\n  (\n    props: TransitionProps & { children?: ReactElement<any, any> },\n    ref: Ref<unknown>,\n  ) => <Slide direction="down" ref={ref} {...props} />,\n);\n\nconst Content = styled.div({\n  display: "flex",\n  flexDirection: "column",\n  gap: "20px",\n});\n\nconst DialogInnerContent = () => {\n  const [expandedGroup, setExpandedGroup] = useState<string | null>(null);\n  const [uniqueServices, setUniqueServices] = useState<NewCategory[]>([]);\n  const [currentService, setCurrentService] = useState<NewCategory>();\n  const [groupedServices, setGroupedServices] = useState<Map<string, NewCategory[]>>();\n  const dispatch = useAppDispatch();\n  const { enqueueSnackbar } = useSnackbar();\n  const newServiceOperationServices = useAppSelector(selectNewCategoriesAsArray);\n  const { loading, error } = useAppSelector(selectNewCategoryServiceRequestStatus);\n\n  async function groupServices() {\n    const groupedServsMap = new Map();\n    const uniqueNewServiceOperationServices = newServiceOperationServices.filter(\n      (service, index, self) => index === self.findIndex((s) => s.id === service.id)\n    );\n\n    setUniqueServices(uniqueNewServiceOperationServices);\n\n    for (const service of uniqueNewServiceOperationServices) {\n      const currentUri = service.uri ?? "other";\n      if (groupedServsMap.has(currentUri)) {\n        groupedServsMap.get(currentUri).push(service);\n      } else {\n        groupedServsMap.set(currentUri, [service]);\n      }\n    }\n    setGroupedServices(groupedServsMap);\n  }\n\n  useEffect(() => {\n    if (newServiceOperationServices) {\n      groupServices();\n    }\n  }, [newServiceOperationServices]);\n\n  const handleClose = () => {\n    // Reset selected service when dialog is closed\n    setCurrentService(undefined);\n    dispatch(\n      updateUI({\n        openNewServiceOperationDialog: false,\n      }),\n    );\n  };\n\n  const handleChange = (event: SelectChangeEvent<string>) => {\n    const val = newServiceOperationServices.find(\n      (service) => service.id === event.target.value,\n    );\n    if (val) {\n      console.log("current service", val);\n      setCurrentService(val);\n    }\n  };\n\n  const handleSubmit = async (formState: Record<string, any>, reset?: Function) => {\n    if (!currentService) return;\n    try {\n      const { data } = await dispatch(\n        newCategoryService({\n          newCategory: currentService,\n          formValues: formState,\n        })\n      ).unwrap();\n      if (reset) reset();\n      setCurrentService(undefined);\n      dispatch(updateUI({ openNewServiceOperationDialog: false }));\n      const nColumns = Object.keys(data.columns).length;\n      const infoText = `${nColumns} ${nColumns > 1 ? "columns" : "column"} added`;\n      enqueueSnackbar(infoText, {\n        autoHideDuration: 3000,\n        anchorOrigin: { vertical: "bottom", horizontal: "center" },\n      });\n      return data;\n    } catch (err: any) {\n      enqueueSnackbar(err.message || "An error occurred while formatting dates.", {\n        variant: "error",\n        autoHideDuration: 4000,\n        anchorOrigin: { vertical: "bottom", horizontal: "center" },\n      });\n      throw err;\n    }\n  };\n  const toggleGroup = (uri: string) => {\n    setExpandedGroup((prev) => (prev === uri ? null : uri));\n  };\n  const handleHeaderClick = (e, uri) => {\n    e.stopPropagation(); // Prevent the Select from closing\n    setExpandedGroup((prev) => (prev === uri ? null : uri));\n  };\n  return (\n    <>\n      <FormControl className="field">\n        <Select\n          value={currentService ? currentService.id : ""}\n          onChange={handleChange}\n          variant="outlined"\n          MenuProps={{\n            PaperProps: {\n              style: {\n                maxHeight: "400px",\n              },\n            },\n          }}\n          renderValue={(selected) => {\n            const selectedService = newServiceOperationServices.find(\n              (service) => service.id === selected,\n            );\n            return selectedService ? selectedService.name : "";\n          }}\n        >\n          {uniqueServices.map((newCategory) => (\n            <MenuItem\n              key={newCategory.id}\n              value={newCategory.id}\n              sx={{ pl: 4 }}\n              onClick={() => handleChange({ target: { value: newCategory.id } })}\n            >\n              {newCategory.name}\n            </MenuItem>\n          ))}\n        </Select>\n      </FormControl>\n      {currentService && (\n        <>\n          <SquaredBox\n            dangerouslySetInnerHTML={{ __html: currentService.description }}\n          />\n          {error && <Typography color="error">{error.message}</Typography>}\n          <Divider />\n          <DynamicNewServiceOperationForm\n            loading={loading}\n            onSubmit={handleSubmit}\n            onCancel={handleClose}\n            service={currentService}\n          />\n        </>\n      )}\n    </>\n  );\n};\n\nexport type NewCategoryServiceDialogProps = {\n  open: boolean;\n  handleClose: () => void;\n};\n\nconst NewCategoryServiceDialog: FC<NewCategoryServiceDialogProps> = ({ open, handleClose }) => {\n  const dispatch = useAppDispatch();\n\n  return (\n    <Dialog open={open} TransitionComponent={Transition} onClose={handleClose}>\n      <Stack\n        direction="row"\n        alignItems="center"\n        justifyContent="space-between"\n      >\n        <DialogTitle>NewCategoryService</DialogTitle>\n        <IconButton\n          sx={{\n            color: "rgba(0, 0, 0, 0.54)",\n            marginRight: "20px",\n          }}\n          onClick={() => {\n            dispatch(updateUI({ openHelpDialog: true, tutorialStep: stepNumber }));\n          }}\n        >\n          <HelpOutlineRounded />\n        </IconButton>\n      </Stack>\n      <DialogContent>\n        <DialogContentText paddingBottom="10px">\n          Select a service:\n        </DialogContentText>\n        <Content>\n          <DialogInnerContent />\n        </Content>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default NewCategoryServiceDialog;\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/pages/Viewer/TableViewer/SubToolbar.tsx"',title:'"src/pages/Viewer/TableViewer/SubToolbar.tsx"'},'import { ..., selectNewServiceOperationDialogStatus, } from "@store/slices/table/table.selectors";\nimport NewCategoryServiceDialog from "../NewCategoryServiceDialog/NewCategoryServiceDialog";\n\nconst SubToolbar = ({ ... }) => {\n  const openNewServiceOperationDialog = useAppSelector(selectNewServiceOperationDialogStatus);\n    return (\n      <>\n        <ToolbarActions>\n          ...\n          {!isViewOnly && (\n            <ActionGroup>\n              {/* NewCategoryService */}\n                <Tooltip\n                  title={!isCellSelected ? "Select a column to enable NewCategoryService function"\n                    : "NewCategoryService selected column(s)"}\n                  arrow\n                >\n                  <span>\n                    <Button\n                      sx={{\n                        textTransform: "none",\n                      }}\n                      color="primary"\n                      disabled={!isCellSelected}\n                      onClick={() => dispatch(updateUI({ openNewServiceOperationDialog: true }))}\n                      variant="contained"\n                    >\n                      NewCategoryService\n                    </Button>\n                  </span>\n                </Tooltip>\n                ...\n            </ActionGroup>\n          )}\n          ...\n        </ToolbarActions>\n        ...\n        <NewCategoryServiceDialog\n          open={openNewServiceOperationDialog}\n          handleClose={() => handleExtensionClose("openNewServiceOperationDialog")}\n        />\n        ...\n      </>\n    );\n};\n\nexport default SubToolbar;\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/pages/Viewer/TableViewer/Menus/ContextMenus/ContextMenuColumn.tsx"',title:'"src/pages/Viewer/TableViewer/Menus/ContextMenus/ContextMenuColumn.tsx"'},"...\n/**\n * Handle newCategoryService column action.\n */\n const handleNewCategoryService = useCallback(() => {\n    if (isCellSelected) {\n      dispatch(updateUI({ openNewServiceOperationDialog: true }));\n      handleClose();\n    }\n  }, [isCellSelected, dispatch, handleClose]);\n ...\n\n  return (\n    <MenuBase handleClose={handleClose} {...props}>\n      <StyledMenuList autoFocus >\n        <MenuItemIconLabel\n          onClick={handleNewCategoryService}\n          Icon={TransformIcon}>\n            NewCategoryService column\n        </MenuItemIconLabel>\n        ...\n      </StyledMenuList>\n    </MenuBase>\n  );\n};\n\nexport default ContextMenuColumn;\n")),(0,a.kt)("h3",{id:"4-update-dynamic-forms-if-applicable"},"4. Update Dynamic Forms (if applicable)"),(0,a.kt)("p",null,"Finally, adapt the Dynamic Form component to support the new Category Service. The form leverages\nreact-hook-form to handle input state, validation, and submission, while dynamically rendering\nfields based on the selected service. This approach allows seamless reuse of the existing form\nlogic for any new service type, including conditional fields and suggestion lists."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/components/core/DynamicForm/DynamicForm.tsx"',title:'"src/components/core/DynamicForm/DynamicForm.tsx"'},'import { ..., NewCategory, } from "@store/slices/config/interfaces/config";\n\nexport type DynamicFormProps = {\n  loading: boolean | undefined;\n  service: Extender | ... | NewCategory;\n  onSubmit: (formState: Record<string, any>, reset?: Function) => void;\n  onCancel: () => void;\n};\n...\n')),(0,a.kt)("p",null,"With both backend and frontend updates completed, the new Category Service is fully integrated,\nallowing the various services, added in the ",(0,a.kt)("inlineCode",{parentName:"p"},"newCategoryService")," folder in the backend,\nto be directly used in the frontend through the ",(0,a.kt)("inlineCode",{parentName:"p"},"DynamicForm"),"."))}d.isMDXComponent=!0}}]);