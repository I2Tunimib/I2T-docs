"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[798],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,g=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(g,s(s({ref:t},p),{},{components:n})):a.createElement(g,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8215:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);const o=function({children:e,hidden:t,className:n}){return a.createElement("div",{role:"tabpanel",hidden:t,className:n},e)}},6396:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(7462),o=n(7294),r=n(2389),s=n(9443);const i=function(){const e=(0,o.useContext)(s.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e};var l=n(3810),c=n(6010);const p="tabItem_vU9c";function u(e){const{lazy:t,block:n,defaultValue:a,values:r,groupId:s,className:u}=e,d=o.Children.map(e.children,(e=>{if((0,o.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=r??d.map((({props:{value:e,label:t}})=>({value:e,label:t}))),g=(0,l.lx)(m,((e,t)=>e.value===t.value));if(g.length>0)throw new Error(`Docusaurus error: Duplicate values "${g.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const b=null===a?a:a??d.find((e=>e.props.default))?.props.value??d[0]?.props.value;if(null!==b&&!m.some((e=>e.value===b)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${b}" but none of its children has the corresponding value. Available values are: ${m.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:f,setTabGroupChoices:h}=i(),[T,k]=(0,o.useState)(b),y=[],{blockElementScrollPositionUntilNextRender:I}=(0,l.o5)();if(null!=s){const e=f[s];null!=e&&e!==T&&m.some((t=>t.value===e))&&k(e)}const A=e=>{const t=e.currentTarget,n=y.indexOf(t),a=m[n].value;a!==T&&(I(t),k(a),null!=s&&h(s,a))},v=e=>{let t=null;switch(e.key){case"ArrowRight":{const n=y.indexOf(e.currentTarget)+1;t=y[n]||y[0];break}case"ArrowLeft":{const n=y.indexOf(e.currentTarget)-1;t=y[n]||y[y.length-1];break}}t?.focus()};return o.createElement("div",{className:"tabs-container"},o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":n},u)},m.map((({value:e,label:t})=>o.createElement("li",{role:"tab",tabIndex:T===e?0:-1,"aria-selected":T===e,className:(0,c.Z)("tabs__item",p,{"tabs__item--active":T===e}),key:e,ref:e=>y.push(e),onKeyDown:v,onFocus:A,onClick:A},t??e)))),t?(0,o.cloneElement)(d.filter((e=>e.props.value===T))[0],{className:"margin-vert--md"}):o.createElement("div",{className:"margin-vert--md"},d.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function d(e){const t=(0,r.Z)();return o.createElement(u,(0,a.Z)({key:String(t)},e))}},864:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>i,contentTitle:()=>l,metadata:()=>c,toc:()=>p,default:()=>d});var a=n(7462),o=(n(7294),n(3905)),r=n(6396),s=n(8215);const i={sidebar_position:3},l="Frontend Integration",c={unversionedId:"frontend/new-global-action/frontend",id:"frontend/new-global-action/frontend",title:"Frontend Integration",description:"Each action is implemented as a button within the Toolbar\u2019s Stack section. Depending on the type of action,",source:"@site/docs/frontend/new-global-action/frontend.md",sourceDirName:"frontend/new-global-action",slug:"/frontend/new-global-action/frontend",permalink:"/I2T-docs/frontend/new-global-action/frontend",editUrl:"https://github.com/I2Tunimib/I2T-docs/docs/frontend/new-global-action/frontend.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Backend Integration",permalink:"/I2T-docs/frontend/new-global-action/backend"},next:{title:"Known bugs",permalink:"/I2T-docs/known-bugs"}},p=[{value:"1. Update API and Config",id:"1-update-api-and-config",children:[],level:3},{value:"2. Update the Global Store (Config and Table Slices)",id:"2-update-the-global-store-config-and-table-slices",children:[],level:3},{value:"3. Add UI Components",id:"3-add-ui-components",children:[],level:3}],u={toc:p};function d({components:e,...t}){return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"frontend-integration"},"Frontend Integration"),(0,o.kt)("p",null,"Each action is implemented as a button within the ",(0,o.kt)("inlineCode",{parentName:"p"},"Toolbar"),"\u2019s Stack section. Depending on the type of action,\nthe corresponding onClick handler can:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Dispatch a Redux thunk")," that performs a backend request (e.g., saveTable, automaticAnnotation)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Trigger a UI state update")," that opens a dialog (e.g., ExportDialog, SettingsDialog, HelpDialog).")),(0,o.kt)("p",null,"The following code examples (ExportDialog and automaticAnnotation) serve as references for\nimplementing new Global Table Actions."),(0,o.kt)("h3",{id:"1-update-api-and-config"},"1. Update API and Config"),(0,o.kt)("p",null,"In this first step, define the backend endpoint and its configuration entry.\nThis ensures that the new Global Table Action has a registered API route and can be called by the frontend\nthrough the service layer."),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"autoAnnotationAC",label:"Automatic Annotation",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/services/api/table.ts"',title:'"src/services/api/table.ts"'},'const tableAPI = {\n  ...,\n  automaticAnnotation: (\n    params: Record<string, string | number> = {},\n    data: any,\n  ) => {\n    return apiClient.post<any>(\n      apiEndpoint({\n        endpoint: "AUTOMATIC_ANNOTATION",\n        paramsValue: { ...params },\n      }),\n      data,\n      {\n        headers: {\n          Authorization: `Bearer ${localStorage.getItem("token")}`,\n        },\n      },\n    );\n  },\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/config.ts"',title:'"src/config.ts"'},'export type ApiConfig = {\n  GLOBAL: string;\n  ENDPOINTS: {\n    ...,\n    AUTOMATIC_ANNOTATION: Endpoint;\n  }\n}\n\nconst CONFIG: AppConfig = {\n  API: {\n    // global endpoint prefixed to each path, unless useGlobal is set to false\n    GLOBAL: import.meta.env.VITE_BACKEND_API_URL || "",\n    ENDPOINTS: {\n      ...,\n      AUTOMATIC_ANNOTATION: {\n        path: "/reconcilers/mantis/dataset/:datasetId/table/:tableId",\n      },\n    }\n  }\n}\n')),(0,o.kt)("p",null,"The automaticAnnotation endpoint performs a POST request because it sends the entire table structure (rows,\ncolumns, and metadata) to the backend for processing. It represents a single service endpoint, since only\none annotation workflow is available. This kind of action usually triggers a long-running process and\nupdates the table status on completion.")),(0,o.kt)(s.Z,{value:"exportTableAC",label:"Export Table",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/services/api/table.ts"',title:'"src/services/api/table.ts"'},'const tableAPI = {\n  ...,\n  exportTable: (\n    format: string,\n    params: Record<string, string | number> = {},\n  ) => {\n    return apiClient.get < any > (\n      apiEndpoint({\n        endpoint: "EXPORT",\n        subEndpoint: format,\n        paramsValue: params,\n      }),\n      {\n        headers: {\n          Authorization: `Bearer ${localStorage.getItem("token")}`,\n        },\n      },\n    );\n  },\n}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/config.ts"',title:'"src/config.ts"'},'export type ApiConfig = {\n  GLOBAL: string;\n  ENDPOINTS: {\n    ...,\n    EXPORT: Endpoint[];\n  }\n}\n\nconst CONFIG: AppConfig = {\n  API: {\n    // global endpoint prefixed to each path, unless useGlobal is set to false\n    GLOBAL: import.meta.env.VITE_BACKEND_API_URL || "",\n    ENDPOINTS: {\n      ...,\n      EXPORT: [\n        {\n          path: "/dataset/:datasetId/table/:tableId/export?format=w3c",\n          name: "JSON (W3C Compliant)",\n          params: {\n            extension: "json",\n            postDownload: (data: any) => JSON.stringify(data, null, 2),\n          },\n        },\n        {\n          path: "/dataset/:datasetId/table/:tableId/export?format=csv",\n          name: "CSV",\n          params: {\n            extension: "csv",\n          },\n        },\n        {\n          path: "/dataset/:datasetId/table/:tableId/code?format=python",\n          name: "Python pipeline",\n          params: {\n            extension: "py",\n            postDownload: (data: any) => {\n              if (typeof data === "string") {\n                return data;\n              }\n              if (typeof data === "object" && data !== null) {\n                return JSON.stringify(data, null, 2);\n              }\n              return String(data);\n            },\n          },\n        },\n        {\n          path: "/dataset/:datasetId/table/:tableId/code?format=notebook",\n          name: "Jupyter notebook pipeline",\n          params: {\n            extension: "ipynb",\n            postDownload: (data: any) => {\n              if (typeof data === "string") {\n                try {\n                  // Try to parse and re-stringify to ensure proper formatting\n                  return JSON.stringify(JSON.parse(data), null, 2);\n                } catch {\n                  // If it\'s not valid JSON, return as-is\n                  return data;\n                }\n              }\n              if (typeof data === "object" && data !== null) {\n                return JSON.stringify(data, null, 2);\n              }\n              return String(data);\n            },\n          },\n        },\n      ],\n    };\n  };\n\n')),(0,o.kt)("p",null,"The exportTable API performs a GET request and supports multiple endpoints, each corresponding to a specific\nexport format (JSON, CSV, Python, Notebook). Unlike automaticAnnotation, it does not send the table content,\nonly identifiers (datasetId, tableId, and optional format). The list of available export options is defined\nin the configuration file and used dynamically by the UI to populate the ExportDialog."))),(0,o.kt)("h3",{id:"2-update-the-global-store-config-and-table-slices"},"2. Update the Global Store (Config and Table Slices)"),(0,o.kt)("p",null,"In this step, integrate the new Global Table Action into the Redux store.\nDepending on the action type, this may involve:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Defining async thunks to handle backend requests (e.g., automatic annotation, export)."),(0,o.kt)("li",{parentName:"ul"},"Adding slice updates such as addCase handlers for actions that modify the application state."),(0,o.kt)("li",{parentName:"ul"},"Introducing UI flags (e.g., dialog visibility) for actions managed entirely on the frontend."),(0,o.kt)("li",{parentName:"ul"},"Creating selectors to access the action\u2019s status or related UI state.\nThese updates ensure consistent handling of both backend-triggered and UI-driven actions through the global store.")),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"autoAnnotationStore",label:"Automatic Annotation",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.slice.ts"',title:'"src/store/slices/table/table.slice.ts"'},".addCase(\n  automaticAnnotation.fulfilled,\n  (state, action: PayloadAction<Payload<AutomaticAnnotationPayload>>) => {\n    const { datasetId, tableId, mantisStatus } = action.payload;\n    state.entities.tableInstance.mantisStatus = mantisStatus;\n    state.ui.settings.isViewOnly = true;\n  },\n)\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.selectors.ts"',title:'"src/store/slices/table/table.selectors.ts"'},"export const selectAutomaticAnnotationStatus = createSelector(\n  selectRequests, \n  (requests) =>\n    getRequestStatus(requests, TableThunkActions.AUTOMATIC_ANNOTATION)\n);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.thunk.ts"',title:'"src/store/slices/table/table.thunk.ts"'},'export enum TableThunkActions {\n  ...\n  AUTOMATIC_ANNOTATION = "automaticAnnotation",\n}\n\ntype AutomaticAnnotationThunkInputProps = {\n  datasetId: string;\n  tableId: string;\n};\n\ntype AutomaticAnnotationThunkOutputProps = {\n  datasetId: string;\n  tableId: string;\n  mantisStatus: "PENDING";\n};\n\nexport const automaticAnnotation = createAsyncThunk<\n  AutomaticAnnotationThunkOutputProps, \n  AutomaticAnnotationThunkInputProps\n>(`${ACTION_PREFIX}/automaticAnnotation`, async (params, { getState }) => {\n  const { table } = getState() as any;\n  const { entities } = table;\n  const data = {\n    rows: entities.rows.byId,\n    columns: entities.columns.byId,\n    table: entities.tableInstance,\n  };\n  const response = await tableAPI.automaticAnnotation(params, data);\n  return response.data;\n});\n')),(0,o.kt)("p",null,"This action differs from Export in that it triggers a backend workflow rather than a simple download.",(0,o.kt)("br",{parentName:"p"}),"\n","It updates the table\u2019s state (",(0,o.kt)("inlineCode",{parentName:"p"},"mantisStatus = PENDING"),") and locks the UI to read-only mode while the automatic",(0,o.kt)("br",{parentName:"p"}),"\n","annotation process runs asynchronously on the server.")),(0,o.kt)(s.Z,{value:"exportTableStore",label:"Export Table",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/config/config.selectors.ts"',title:'"src/store/slices/config/config.selectors.ts"'},"export const selectAppConfigExportFormats = createSelector(\n  selectStoreConfig,\n  (storeConfig) => storeConfig.app.API.ENDPOINTS.EXPORT\n);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/interfaces/table.ts"',title:'"src/store/slices/table/interfaces/table.ts"'},"export interface TableUIState {\n  ...;\n  openExportDialog: boolean;\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.slice.ts"',title:'"src/store/slices/table/table.slice.ts"'},"const initialState: TableState = {\n  entities: {...},\n  ui: {\n    ...,\n    openExportDialog: false,\n  }\n\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.selectors.ts"',title:'"src/store/slices/table/table.selectors.ts"'},"export const selectExportDialogStatus = createSelector(\n  selectUIState,\n  (ui) => ui.openExportDialog\n);\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/store/slices/table/table.thunk.ts"',title:'"src/store/slices/table/table.thunk.ts"'},'export enum TableThunkActions {\n  ...\n  EXPORT_TABLE = "exportTable",\n}\n\nexport const exportTable = createAsyncThunk(\n  `${ACTION_PREFIX}/exportTable`,\n  async ({\n    format,\n    params,\n  }: {\n    format: string;\n    params: Record<string, string | number>;\n  }) => {\n    const response = await tableAPI.exportTable(format, params);\n    return response.data;\n  },\n);\n')),(0,o.kt)("p",null,"Unlike Automatic Annotation, this action does not modify the table state or trigger any background process.",(0,o.kt)("br",{parentName:"p"}),"\n","It simply handles user-initiated data export, managing only UI elements such as the export dialog visibility."))),(0,o.kt)("h3",{id:"3-add-ui-components"},"3. Add UI Components"),(0,o.kt)("p",null,"Finally, integrate the corresponding button and any associated UI components into the frontend.\nFor any new action, you should:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Add a button in the Toolbar that triggers the action."),(0,o.kt)("li",{parentName:"ul"},"Connect the button to the corresponding Redux thunk or UI state update."),(0,o.kt)("li",{parentName:"ul"},"Include any necessary dialogs or modals that allow users to configure or execute the action."),(0,o.kt)("li",{parentName:"ul"},"Ensure proper enabling/disabling of the button based on the action\u2019s current state.")),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(s.Z,{value:"autoAnnotationUI",label:"Automatic Annotation",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/pages/Viewer/Toolbar/Toolbar.tsx"',title:'"src/pages/Viewer/Toolbar/Toolbar.tsx"'},'const Toolbar = () => {\n  const { loading: loadingAutomaticAnnotation } = useAppSelector(selectAutomaticAnnotationStatus);\n\n  const handleAutomaticAnnotation = () => {\n    dispatch(automaticAnnotation({ datasetId, tableId }));\n  };\n...\nreturn (\n  ...\n  <Button\n    color="primary"\n    disabled={loadingAutomaticAnnotation || (currentTable && currentTable.mantisStatus === \'PENDING\')}\n    onClick={handleAutomaticAnnotation}\n    startIcon={<PlayCircleOutlineRoundedIcon />}\n    variant="contained"\n  >\n    Automatic annotation\n  </Button>\n  ...\n);\n')),(0,o.kt)("p",null,"This button directly triggers a backend process without user configuration, unlike Export.\nIt acts as a one-click action that runs semantic enrichment on the table, using a thunk to manage",(0,o.kt)("br",{parentName:"p"}),"\n","the asynchronous request. During execution, the button is automatically disabled to prevent repeated submissions.")),(0,o.kt)(s.Z,{value:"exportTableUI",label:"Export Table",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/pages/Viewer/Toolbar/Toolbar.tsx"',title:'"src/pages/Viewer/Toolbar/Toolbar.tsx"'},'import ExportDialog from \'../TableViewer/ExportDialog\';\n\nreturn (\n  ...\n  {API.ENDPOINTS.EXPORT && API.ENDPOINTS.EXPORT.length > 0 && (\n    <>\n      <Button\n        onClick={() => dispatch(updateUI({ openExportDialog: true }))}\n        variant="contained"\n        size="medium"\n        startIcon={<SystemUpdateAltRoundedIcon />}\n      >\n        Export\n      </Button>\n      <ExportDialog />\n    </>\n  )}\n);\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="src/pages/Viewer/TableViewer/ExportDialog/ExportDialog.tsx"',title:'"src/pages/Viewer/TableViewer/ExportDialog/ExportDialog.tsx"'},'import { useAppDispatch, useAppSelector } from "@hooks/store";\nimport {\n    Button,\n    Dialog,\n    DialogActions,\n    DialogContent,\n    DialogContentText,\n    DialogTitle,\n    FormControl,\n    InputLabel,\n    MenuItem,\n    Select,\n    SelectChangeEvent,\n    Tooltip,\n} from "@mui/material";\nimport { selectAppConfig } from "@store/slices/config/config.selectors";\nimport {\n    selectCurrentTable,\n    selectExportDialogStatus,\n    selectIsUnsaved,\n} from "@store/slices/table/table.selectors";\nimport { updateUI } from "@store/slices/table/table.slice";\nimport { exportTable } from "@store/slices/table/table.thunk";\nimport fileDownload from "js-file-download";\nimport { useSnackbar } from "notistack";\nimport { FC, useState, useEffect } from "react";\nimport { useParams } from "react-router-dom";\n\ninterface ExportDialogProps {}\n\nconst ExportDialog: FC<ExportDialogProps> = () => {\n  const [format, setFormat] = useState<string>("");\n  const dispatch = useAppDispatch();\n  const isOpen = useAppSelector(selectExportDialogStatus);\n  const { datasetId, tableId } = useParams<{\n    datasetId: string;\n    tableId: string;\n  }>();\n  const { name: tableName } = useAppSelector(selectCurrentTable);\n  const { API } = useAppSelector(selectAppConfig);\n  const isUnsaved = useAppSelector(selectIsUnsaved);\n  const { enqueueSnackbar } = useSnackbar();\n\n  const handleClose = () => {\n    dispatch(updateUI({ openExportDialog: false }));\n  };\n\n  useEffect(() => {\n    if (API.ENDPOINTS.EXPORT && API.ENDPOINTS.EXPORT.length > 0) {\n      setFormat(API.ENDPOINTS.EXPORT[0].name || "");\n    }\n  }, [API]);\n\n  const handleChange = (event: SelectChangeEvent<string>) => {\n    const newFormat = event.target.value;\n\n    // Check if the selected format is a pipeline and we have unsaved changes\n    const isPipeline =\n      newFormat === "Python pipeline" ||\n      newFormat === "Jupyter notebook pipeline";\n\n    if (isPipeline && isUnsaved) {\n      // Show warning but don\'t change the format\n      enqueueSnackbar(\n        "Please save your changes before generating a pipeline. Click the save icon in the toolbar.",\n        {\n          variant: "warning",\n          autoHideDuration: 6000,\n          anchorOrigin: {\n            vertical: "top",\n            horizontal: "center",\n          },\n        },\n      );\n      return;\n    }\n\n    // Otherwise update the format\n    setFormat(newFormat);\n  };\n\n  const handleConfirm = () => {\n    const exportEndpoint = API.ENDPOINTS.EXPORT.find(\n      (endpoint) => endpoint.name === format,\n    );\n    if (!exportEndpoint) {\n      return;\n    }\n\n    // Don\'t allow pipeline exports if there are unsaved changes\n    const isPipeline =\n      format === "Python pipeline" || format === "Jupyter notebook pipeline";\n    if (isPipeline && isUnsaved) {\n      dispatch(updateUI({ openExportDialog: false }));\n      enqueueSnackbar(\n        "Please save your changes before generating a pipeline. Click the save icon in the toolbar.",\n        {\n          variant: "warning",\n          autoHideDuration: 6000,\n          anchorOrigin: {\n            vertical: "top",\n            horizontal: "center",\n          },\n        },\n      );\n      return;\n    }\n\n    const { params } = exportEndpoint;\n\n    dispatch(\n      exportTable({\n        format,\n        params: { tableId, datasetId },\n      }),\n    )\n    .unwrap()\n    .then((data) => {\n      console.log("Export data received:", {\n        format,\n        dataType: typeof data,\n        isArray: Array.isArray(data),\n        dataPreview: typeof data === "string" ? data.substring(0, 100) : data,\n      });\n\n      if (params) {\n        const { postDownload, extension } = params;\n        const processedData = postDownload ? postDownload(data) : data;\n\n        console.log("Processed data for download:", {\n          originalType: typeof data,\n          processedType: typeof processedData,\n          processedPreview:\n            typeof processedData === "string"\n              ? processedData.substring(0, 100)\n              : processedData,\n        });\n\n        fileDownload(processedData, `${tableName}.${extension}`);\n      }\n    });\n    dispatch(updateUI({ openExportDialog: false }));\n  };\n\n  return (\n    <Dialog open={isOpen} onClose={handleClose}>\n      <DialogTitle>Export table</DialogTitle>\n      <DialogContent>\n        <DialogContentText>\n          Choose an export format from those available:\n        </DialogContentText>\n        <FormControl fullWidth sx={{ marginTop: "20px" }}>\n          <InputLabel id="export-label">Export format</InputLabel>\n            <Select\n              labelId="export-label"\n              id="export-select"\n              value={format}\n              label="Export format"\n              onChange={handleChange}\n            >\n              {API.ENDPOINTS.EXPORT.map(({ name, path }) => {\n                // Disable pipeline options if there are unsaved changes\n                const isPipeline =\n                  name === "Python pipeline" ||\n                  name === "Jupyter notebook pipeline";\n                const isDisabled = isPipeline && isUnsaved;\n\n                // For disabled items, wrap with Tooltip\n                if (isDisabled) {\n                  return (\n                    <Tooltip\n                      key={path}\n                      title="You must save your changes before generating a pipeline"\n                      placement="right"\n                    >\n                      <span>\n                        <MenuItem\n                          value={name}\n                          disabled={isDisabled}\n                          sx={{ color: "text.disabled", fontStyle: "italic" }}\n                        >\n                          {name} (save required)\n                        </MenuItem>\n                      </span>\n                    </Tooltip>\n                  );\n                }\n\n                // For enabled items, render MenuItem directly without Tooltip wrapper\n                return (\n                  <MenuItem key={path} value={name}>\n                    {name}\n                  </MenuItem>\n                );\n              })}\n            </Select>\n        </FormControl>\n      </DialogContent>\n      <DialogActions>\n        <Button onClick={handleClose}>Cancel</Button>\n        <Button color="primary" onClick={handleConfirm}>Confirm</Button>\n      </DialogActions>\n    </Dialog>\n  );\n};\n\nexport default ExportDialog;\n')),(0,o.kt)("p",null,"Export, unlike Automatic Annotation, involves user interaction through a dialog.",(0,o.kt)("br",{parentName:"p"}),"\n","The button only opens the ExportDialog component, where the user selects the format before dispatching",(0,o.kt)("br",{parentName:"p"}),"\n","the export action. The UI logic is therefore more interaction-driven and focused on file generation\nrather than backend processing."))))}d.isMDXComponent=!0}}]);